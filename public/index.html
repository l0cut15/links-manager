<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Home Server UBUNTU</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&display=swap" rel="stylesheet">
    <style>
        .link-item {
            cursor: move;
            user-select: none;
        }
        .link-item.dragging {
            opacity: 0.5;
            background: rgba(0, 0, 0, 0.1);
        }
        .drag-handle {
            cursor: move;
            padding: 0 10px;
            color: #666;
        }
        .links-list.drag-over {
            background: rgba(0, 123, 255, 0.1);
            border: 2px dashed #007bff;
            border-radius: 4px;
        }
    </style>
</head>
<body class="theme-dark">    
    <h1>Home Server</h1>

    <!-- Search overlay -->
    <div id="search-overlay" class="search-overlay hidden">
        <div class="search-container">
            <div class="search-input-wrapper">
                <i class="fas fa-search search-icon"></i>
                <input
                    type="text"
                    id="search-input"
                    class="search-input"
                    placeholder="Search links... (type to filter)"
                    autocomplete="off"
                    autocorrect="off"
                    spellcheck="false"
                />
                <button id="search-close" class="search-close" aria-label="Close search">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div id="search-results" class="search-results">
                <!-- Results will be populated dynamically -->
            </div>
            <div class="search-footer">
                <span class="search-hint">
                    <kbd>↑</kbd><kbd>↓</kbd> navigate •
                    <kbd>Enter</kbd> open •
                    <kbd>Esc</kbd> close
                </span>
            </div>
        </div>
    </div>

    <div class="columns-container">
        <div class="column">
            <h2>Servers</h2>
            <div id="servers-container" class="links-list"></div>
            <button id="add-servers" class="add-button column-add">
                <i class="fas fa-plus"></i> Add Server Link
            </button>
        </div>
        <div class="column">
            <h2>Infrastructure & System</h2>
            <div id="infrastructure-container" class="links-list"></div>
            <button id="add-infrastructure" class="add-button column-add">
                <i class="fas fa-plus"></i> Add Infrastructure Link
            </button>
        </div>
        <div class="column">
            <h2>Media & Apps</h2>
            <div id="media-container" class="links-list"></div>
            <button id="add-media" class="add-button column-add">
                <i class="fas fa-plus"></i> Add Media/App Link
            </button>
        </div>
        <div class="column">
            <h2>Websites</h2>
            <div id="websites-container" class="links-list"></div>
            <button id="add-websites" class="add-button column-add">
                <i class="fas fa-plus"></i> Add Website Link
            </button>
        </div>
    </div>
    <div id="status"></div>

    <script>
        // Constants
        const SELECTORS = {
            STATUS: '#status',
            SERVERS_CONTAINER: '#servers-container',
            INFRASTRUCTURE_CONTAINER: '#infrastructure-container',
            MEDIA_CONTAINER: '#media-container',
            WEBSITES_CONTAINER: '#websites-container',
            ADD_SERVERS: '#add-servers',
            ADD_INFRASTRUCTURE: '#add-infrastructure',
            ADD_MEDIA: '#add-media',
            ADD_WEBSITES: '#add-websites',
            SEARCH_OVERLAY: '#search-overlay',
            SEARCH_INPUT: '#search-input',
            SEARCH_RESULTS: '#search-results',
            SEARCH_CLOSE: '#search-close'
        };
        
        const CSS_CLASSES = {
            LINK_ITEM: 'link-item',
            EDIT_MODE: 'edit-mode',
            DRAGGING: 'dragging',
            DRAG_OVER: 'drag-over',
            LINKS_LIST: 'links-list',
            ACTION_BUTTON: 'action-button',
            ERROR: 'error',
            HIDDEN: 'hidden',
            SELECTED: 'selected',
            SEARCH_RESULT_ITEM: 'search-result-item'
        };
        
        const CATEGORIES = {
            SERVERS: 'servers',
            INFRASTRUCTURE: 'infrastructure',
            MEDIA: 'media',
            WEBSITES: 'websites'
        };
        
        const STATUS_TIMEOUT = 2000;
        
        // Global state
        let links = [];
        let draggedItem = null;
        let searchSelectedIndex = -1;
        let searchFilteredLinks = [];

        /**
         * Validates a URL format
         * @param {string} url - The URL to validate
         * @returns {boolean} True if valid URL format
         */
        function isValidURL(url) {
            if (!url || typeof url !== 'string') return false;
            
            const trimmedUrl = url.trim();
            if (trimmedUrl.length === 0) return false;
            
            // Allow URLs with or without protocol
            const urlPattern = /^(https?:\/\/)?[\w\-]+(\.[\w\-]+)*([:\d]+)?(\/.*)?$/i;
            const localhostPattern = /^(https?:\/\/)?localhost([:\d]+)?(\/.*)?$/i;
            const ipPattern = /^(https?:\/\/)?\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}([:\d]+)?(\/.*)?$/i;
            const localPattern = /^(https?:\/\/)?[\w\-]+\.local([:\d]+)?(\/.*)?$/i;
            
            return urlPattern.test(trimmedUrl) || 
                   localhostPattern.test(trimmedUrl) || 
                   ipPattern.test(trimmedUrl) ||
                   localPattern.test(trimmedUrl);
        }

        /**
         * Validates a link name
         * @param {string} name - The name to validate
         * @returns {boolean} True if valid name
         */
        function isValidName(name) {
            if (!name || typeof name !== 'string') return false;
            const trimmedName = name.trim();
            return trimmedName.length > 0 && trimmedName.length <= 100;
        }

        /**
         * Normalizes a URL by adding protocol if missing
         * @param {string} url - The URL to normalize
         * @returns {string} The normalized URL
         */
        function normalizeURL(url) {
            const trimmedUrl = url.trim();
            if (!trimmedUrl.startsWith('http://') && !trimmedUrl.startsWith('https://')) {
                return 'http://' + trimmedUrl;
            }
            return trimmedUrl;
        }

        /**
         * Shows validation error message
         * @param {string} message - The error message to display
         */
        function showValidationError(message) {
            const statusElement = document.querySelector(SELECTORS.STATUS);
            statusElement.textContent = message;
            statusElement.className = CSS_CLASSES.ERROR;
            setTimeout(() => {
                statusElement.textContent = '';
                statusElement.className = '';
            }, 3000);
        }

        /**
         * Checks if any link is currently in editing mode
         * @returns {boolean} True if any link is being edited
         */
        function hasLinkInEditMode() {
            return links.some(link => link.editing === true);
        }

        /**
         * Shows a status message to the user
         * @param {string} message - The message to display
         * @param {boolean} isError - Whether this is an error message
         */
        function showStatusMessage(message, isError = false) {
            const statusElement = document.querySelector(SELECTORS.STATUS);
            statusElement.textContent = message;
            statusElement.className = isError ? CSS_CLASSES.ERROR : '';
            setTimeout(() => {
                statusElement.textContent = '';
                statusElement.className = '';
            }, 2000);
        }

        /**
         * Creates a DOM element for a single link item
         * @param {Object} link - The link object with name, url, category properties
         * @param {number} index - The index of the link in the links array
         * @returns {HTMLElement} The created link element
         */
        function createLinkElement(link, index) {
            const div = document.createElement('div');
            div.className = CSS_CLASSES.LINK_ITEM;
            div.draggable = !link.editing;
            div.setAttribute('data-index', index);
            
            if (link.editing) {
                const editForm = document.createElement('div');
                editForm.className = CSS_CLASSES.EDIT_MODE;
                
                const nameInput = document.createElement('input');
                nameInput.className = 'name-input';
                nameInput.placeholder = 'Link Name';
                nameInput.value = link.name;
                nameInput.maxLength = 100;
                nameInput.required = true;
                
                const urlInput = document.createElement('input');
                urlInput.className = 'url-input';
                urlInput.placeholder = 'URL (e.g., example.com, 192.168.1.1:8080)';
                urlInput.value = link.url;
                urlInput.required = true;
                
                // Add Enter key support
                const handleEnterKey = (e) => {
                    if (e.key === 'Enter') {
                        saveButton.click();
                    }
                };
                nameInput.addEventListener('keypress', handleEnterKey);
                urlInput.addEventListener('keypress', handleEnterKey);
                
                const saveButton = document.createElement('button');
                saveButton.className = 'action-button edit';
                saveButton.innerHTML = '<i class="fas fa-check"></i>';
                saveButton.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const name = nameInput.value.trim();
                    const url = urlInput.value.trim();
                    
                    // Validate inputs
                    if (!isValidName(name)) {
                        showValidationError('Please enter a valid name (1-100 characters)');
                        nameInput.focus();
                        return;
                    }
                    
                    if (!isValidURL(url)) {
                        showValidationError('Please enter a valid URL (e.g., example.com, 192.168.1.1:8080, localhost:3000)');
                        urlInput.focus();
                        return;
                    }
                    
                    // Check for duplicate names
                    const existingLink = links.find((link, i) => 
                        i !== index && link.name.toLowerCase() === name.toLowerCase()
                    );
                    if (existingLink) {
                        showValidationError('A link with this name already exists');
                        nameInput.focus();
                        return;
                    }
                    
                    links[index].name = name;
                    links[index].url = normalizeURL(url);
                    links[index].editing = false;
                    renderLinks();
                    saveLinks();
                };
                
                const cancelButton = document.createElement('button');
                cancelButton.className = 'action-button delete';
                cancelButton.innerHTML = '<i class="fas fa-times"></i>';
                cancelButton.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // If this is a new empty link, remove it instead of just canceling edit
                    if (links[index].name === '' && links[index].url === '') {
                        links.splice(index, 1);
                    } else {
                        links[index].editing = false;
                    }
                    renderLinks();
                };
                
                editForm.appendChild(nameInput);
                editForm.appendChild(urlInput);
                editForm.appendChild(saveButton);
                editForm.appendChild(cancelButton);
                div.appendChild(editForm);
            } else {
                const dragHandle = document.createElement('span');
                dragHandle.className = 'drag-handle';
                dragHandle.innerHTML = '<i class="fas fa-grip-vertical"></i>';
                
                const linkElement = document.createElement('a');
                linkElement.href = link.url.startsWith('http') ? link.url : 'https://' + link.url;
                linkElement.target = '_blank';
                linkElement.textContent = link.name;
                
                const actions = document.createElement('div');
                actions.className = 'actions';
                
                const editButton = document.createElement('button');
                editButton.className = 'action-button edit';
                editButton.innerHTML = '<i class="fas fa-edit"></i>';
                editButton.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (hasLinkInEditMode()) {
                        showStatusMessage('Please finish editing the current link before editing another one', true);
                        return;
                    }
                    links[index].editing = true;
                    renderLinks();
                };
                
                const deleteButton = document.createElement('button');
                deleteButton.className = 'action-button delete';
                deleteButton.innerHTML = '<i class="fas fa-trash"></i>';
                deleteButton.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (confirm('Are you sure you want to delete this link?')) {
                        links.splice(index, 1);
                        renderLinks();
                        saveLinks();
                    }
                };
                
                actions.appendChild(editButton);
                actions.appendChild(deleteButton);
                
                div.appendChild(dragHandle);
                div.appendChild(linkElement);
                div.appendChild(actions);
            }

            // Add drag and drop event listeners
            div.addEventListener('dragstart', handleDragStart);
            div.addEventListener('dragend', handleDragEnd);
            div.addEventListener('dragover', handleDragOver);
            div.addEventListener('drop', handleDrop);
            
            return div;
        }

        /**
         * Handles the start of a drag operation
         * @param {DragEvent} e - The drag start event
         */
        function handleDragStart(e) {
            // Prevent dragging if clicking on action buttons or if item is in edit mode
            if (e.target.classList.contains('action-button') || 
                e.currentTarget.querySelector('.edit-mode')) {
                e.preventDefault();
                return;
            }
            draggedItem = e.currentTarget;
            e.currentTarget.classList.add(CSS_CLASSES.DRAGGING);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', e.currentTarget.getAttribute('data-index'));
        }

        /**
         * Handles the end of a drag operation
         * @param {DragEvent} e - The drag end event
         */
        function handleDragEnd(e) {
            e.target.classList.remove(CSS_CLASSES.DRAGGING);
            draggedItem = null;
        }

        /**
         * Handles drag over events and provides visual feedback
         * @param {DragEvent} e - The drag over event
         */
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // Add visual feedback for drop zones
            if (e.currentTarget.classList.contains(CSS_CLASSES.LINKS_LIST)) {
                e.currentTarget.classList.add(CSS_CLASSES.DRAG_OVER);
            }
        }

        /**
         * Handles drag leave events and removes visual feedback
         * @param {DragEvent} e - The drag leave event
         */
        function handleDragLeave(e) {
            // Remove visual feedback when leaving drop zone
            if (e.currentTarget.classList.contains(CSS_CLASSES.LINKS_LIST)) {
                e.currentTarget.classList.remove(CSS_CLASSES.DRAG_OVER);
            }
        }

        /**
         * Handles drop events and processes link reordering/categorization
         * @param {DragEvent} e - The drop event
         */
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation(); // Prevent event bubbling
            
            if (!draggedItem) return;


            // Remove visual feedback
            document.querySelectorAll('.' + CSS_CLASSES.LINKS_LIST).forEach(container => {
                container.classList.remove(CSS_CLASSES.DRAG_OVER);
            });

            const fromIndex = parseInt(draggedItem.getAttribute('data-index'));
            if (fromIndex < 0 || fromIndex >= links.length) return; // Validate index
            
            const draggedLink = links[fromIndex];
            if (!draggedLink) return; // Safety check
            
            
            // Check if dropping on a link item or a category container
            if (e.currentTarget.classList.contains(CSS_CLASSES.LINK_ITEM)) {
                // Dropping on another link item
                const toIndex = parseInt(e.currentTarget.getAttribute('data-index'));
                if (toIndex < 0 || toIndex >= links.length || fromIndex === toIndex) return; // Validate
                
                const targetLink = links[toIndex];
                if (!targetLink) return; // Safety check
                
                
                // Create a deep copy of the links array to work with
                const newLinks = [...links];
                const [movedItem] = newLinks.splice(fromIndex, 1);
                
                // If dropping on a link in a different category, change the category
                if (draggedLink.category !== targetLink.category) {
                    movedItem.category = targetLink.category;
                }
                
                // Calculate correct insertion index (adjust if we removed an item before the target)
                const adjustedToIndex = toIndex > fromIndex ? toIndex - 1 : toIndex;
                newLinks.splice(adjustedToIndex, 0, movedItem);
                
                links = newLinks;
                renderLinks();
                saveLinks();
                
            } else if (e.currentTarget.classList.contains(CSS_CLASSES.LINKS_LIST)) {
                // Dropping on a category container - move to end of that category
                const targetCategory = getCategoryFromContainer(e.currentTarget);
                if (!targetCategory) return; // Safety check
                
                
                // Only move if it's a different category
                if (draggedLink.category !== targetCategory) {
                    const newLinks = [...links];
                    const [movedItem] = newLinks.splice(fromIndex, 1);
                    movedItem.category = targetCategory;
                    
                    // Add to end of the target category
                    newLinks.push(movedItem);
                    links = newLinks;
                    renderLinks();
                    saveLinks();
                }
            }
        }

        /**
         * Determines the category based on container element
         * @param {HTMLElement} container - The container element
         * @returns {string} The category name
         */
        function getCategoryFromContainer(container) {
            if (container.id === 'servers-container') return CATEGORIES.SERVERS;
            if (container.id === 'infrastructure-container') return CATEGORIES.INFRASTRUCTURE;
            if (container.id === 'media-container') return CATEGORIES.MEDIA;
            if (container.id === 'websites-container') return CATEGORIES.WEBSITES;
            return CATEGORIES.WEBSITES; // default
        }


        /**
         * Renders all links into their appropriate category containers
         */
        function renderLinks() {
            const serversContainer = document.querySelector(SELECTORS.SERVERS_CONTAINER);
            const infrastructureContainer = document.querySelector(SELECTORS.INFRASTRUCTURE_CONTAINER);
            const mediaContainer = document.querySelector(SELECTORS.MEDIA_CONTAINER);
            const websitesContainer = document.querySelector(SELECTORS.WEBSITES_CONTAINER);
            
            serversContainer.innerHTML = '';
            infrastructureContainer.innerHTML = '';
            mediaContainer.innerHTML = '';
            websitesContainer.innerHTML = '';
            
            // Add drag and drop event listeners to containers
            [serversContainer, infrastructureContainer, mediaContainer, websitesContainer].forEach(container => {
                container.addEventListener('dragover', handleDragOver);
                container.addEventListener('dragleave', handleDragLeave);
                container.addEventListener('drop', handleDrop);
            });
            
            links.forEach((link, index) => {
                const linkElement = createLinkElement(link, index);
                if (link.category === CATEGORIES.SERVERS) {
                    serversContainer.appendChild(linkElement);
                } else if (link.category === CATEGORIES.INFRASTRUCTURE) {
                    infrastructureContainer.appendChild(linkElement);
                } else if (link.category === CATEGORIES.MEDIA) {
                    mediaContainer.appendChild(linkElement);
                } else {
                    websitesContainer.appendChild(linkElement);
                }
            });
        }

        // ============================================
        // SEARCH FUNCTIONALITY
        // ============================================

        /**
         * Calculates fuzzy match score between query and text
         * Higher score = better match
         * @param {string} text - The text to search in (link name)
         * @param {string} query - The search query
         * @returns {number} Match score (0 = no match, higher = better match)
         */
        function fuzzyMatchScore(text, query) {
            if (!query) return 1; // Empty query matches everything

            const textLower = text.toLowerCase();
            const queryLower = query.toLowerCase();

            // Exact match gets highest score
            if (textLower === queryLower) return 10000;

            // Starts with query gets very high score
            if (textLower.startsWith(queryLower)) return 5000;

            // Contains query as substring gets high score
            if (textLower.includes(queryLower)) return 1000;

            // Fuzzy matching: all characters in order
            let textIndex = 0;
            let queryIndex = 0;
            let score = 0;
            let consecutiveMatches = 0;

            while (textIndex < textLower.length && queryIndex < queryLower.length) {
                if (textLower[textIndex] === queryLower[queryIndex]) {
                    score += 1 + consecutiveMatches * 5; // Bonus for consecutive matches
                    consecutiveMatches++;
                    queryIndex++;
                } else {
                    consecutiveMatches = 0;
                }
                textIndex++;
            }

            // If we matched all query characters, return the score
            if (queryIndex === queryLower.length) {
                // Bonus for matching all characters
                return score + 100;
            }

            return 0; // No match
        }

        /**
         * Filters and sorts links based on search query
         * @param {string} query - The search query
         * @returns {Array} Filtered and sorted links
         */
        function filterLinks(query) {
            if (!query.trim()) {
                // Show all links when query is empty
                return [...links].filter(link => !link.editing);
            }

            return links
                .filter(link => !link.editing)
                .map(link => ({
                    ...link,
                    score: fuzzyMatchScore(link.name, query)
                }))
                .filter(link => link.score > 0)
                .sort((a, b) => b.score - a.score)
                .slice(0, 15); // Limit to 15 results
        }

        /**
         * Renders search results in the dropdown
         * @param {Array} results - Filtered links to display
         */
        function renderSearchResults(results) {
            const resultsContainer = document.querySelector(SELECTORS.SEARCH_RESULTS);
            resultsContainer.innerHTML = '';

            if (results.length === 0) {
                // The CSS ::before pseudo-element will show "No matches found"
                return;
            }

            results.forEach((link, index) => {
                const resultItem = document.createElement('div');
                resultItem.className = CSS_CLASSES.SEARCH_RESULT_ITEM;
                resultItem.setAttribute('data-index', index);
                resultItem.setAttribute('data-url', link.url);

                // Icon based on category
                const iconMap = {
                    servers: 'fa-server',
                    infrastructure: 'fa-network-wired',
                    media: 'fa-photo-video',
                    websites: 'fa-globe'
                };
                const iconClass = iconMap[link.category] || 'fa-link';

                resultItem.innerHTML = `
                    <div class="search-result-icon">
                        <i class="fas ${iconClass}"></i>
                    </div>
                    <div class="search-result-content">
                        <div class="search-result-name">${escapeHtml(link.name)}</div>
                        <div class="search-result-url">${escapeHtml(link.url)}</div>
                    </div>
                    <div class="search-result-category">${link.category}</div>
                `;

                // Click handler
                resultItem.addEventListener('click', () => {
                    navigateToLink(link.url);
                });

                // Hover handler to update selection
                resultItem.addEventListener('mouseenter', () => {
                    selectSearchResult(index);
                });

                resultsContainer.appendChild(resultItem);
            });

            // Auto-select first result
            if (searchSelectedIndex === -1 && results.length > 0) {
                selectSearchResult(0);
            }
        }

        /**
         * Escapes HTML to prevent XSS
         * @param {string} text - Text to escape
         * @returns {string} Escaped text
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Selects a search result by index
         * @param {number} index - Index of result to select
         */
        function selectSearchResult(index) {
            const results = document.querySelectorAll('.' + CSS_CLASSES.SEARCH_RESULT_ITEM);

            // Remove previous selection
            results.forEach(item => item.classList.remove(CSS_CLASSES.SELECTED));

            // Validate index
            if (index < 0 || index >= results.length) return;

            searchSelectedIndex = index;
            const selectedItem = results[index];
            selectedItem.classList.add(CSS_CLASSES.SELECTED);

            // Scroll into view if needed
            selectedItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }

        /**
         * Navigates to a link URL
         * @param {string} url - The URL to navigate to
         */
        function navigateToLink(url) {
            const normalizedUrl = url.startsWith('http') ? url : 'http://' + url;
            window.open(normalizedUrl, '_blank');
            closeSearch();
        }

        /**
         * Opens the search overlay
         */
        function openSearch() {
            // Don't open if currently editing a link
            if (hasLinkInEditMode()) {
                return;
            }

            const overlay = document.querySelector(SELECTORS.SEARCH_OVERLAY);
            const input = document.querySelector(SELECTORS.SEARCH_INPUT);

            overlay.classList.remove(CSS_CLASSES.HIDDEN);
            input.value = '';
            input.focus();

            // Show all links initially
            searchFilteredLinks = filterLinks('');
            searchSelectedIndex = -1;
            renderSearchResults(searchFilteredLinks);
        }

        /**
         * Closes the search overlay
         */
        function closeSearch() {
            const overlay = document.querySelector(SELECTORS.SEARCH_OVERLAY);
            overlay.classList.add(CSS_CLASSES.HIDDEN);
            searchSelectedIndex = -1;
            searchFilteredLinks = [];
        }

        /**
         * Handles search input changes
         */
        function handleSearchInput(e) {
            const query = e.target.value;
            searchFilteredLinks = filterLinks(query);
            searchSelectedIndex = -1;
            renderSearchResults(searchFilteredLinks);
        }

        /**
         * Handles keyboard navigation in search
         * @param {KeyboardEvent} e - The keyboard event
         */
        function handleSearchKeydown(e) {
            const resultsCount = searchFilteredLinks.length;

            switch(e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    if (resultsCount > 0) {
                        const nextIndex = (searchSelectedIndex + 1) % resultsCount;
                        selectSearchResult(nextIndex);
                    }
                    break;

                case 'ArrowUp':
                    e.preventDefault();
                    if (resultsCount > 0) {
                        const prevIndex = searchSelectedIndex <= 0
                            ? resultsCount - 1
                            : searchSelectedIndex - 1;
                        selectSearchResult(prevIndex);
                    }
                    break;

                case 'Enter':
                    e.preventDefault();
                    if (searchSelectedIndex >= 0 && searchSelectedIndex < resultsCount) {
                        const selectedLink = searchFilteredLinks[searchSelectedIndex];
                        navigateToLink(selectedLink.url);
                    }
                    break;

                case 'Escape':
                    e.preventDefault();
                    closeSearch();
                    break;
            }
        }

        /**
         * Global keyboard handler for search trigger
         * @param {KeyboardEvent} e - The keyboard event
         */
        function handleGlobalKeydown(e) {
            // Check if user is typing in an input field
            const activeElement = document.activeElement;
            const isTypingInInput = activeElement && (
                activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.classList.contains('name-input') ||
                activeElement.classList.contains('url-input')
            );

            // Trigger search with '/' key (only if not already typing)
            if (e.key === '/' && !isTypingInInput) {
                e.preventDefault();
                openSearch();
            }
        }

        /**
         * Initializes search functionality
         */
        function initializeSearch() {
            const overlay = document.querySelector(SELECTORS.SEARCH_OVERLAY);
            const input = document.querySelector(SELECTORS.SEARCH_INPUT);
            const closeButton = document.querySelector(SELECTORS.SEARCH_CLOSE);

            // Input handler
            input.addEventListener('input', handleSearchInput);
            input.addEventListener('keydown', handleSearchKeydown);

            // Close button handler
            closeButton.addEventListener('click', closeSearch);

            // Click overlay backdrop to close
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeSearch();
                }
            });

            // Global keyboard shortcut
            document.addEventListener('keydown', handleGlobalKeydown);
        }

        /**
         * Loads links from the server API
         * @async
         */
        async function loadLinks() {
            try {
                const response = await fetch('/api/links');
                links = await response.json();
                renderLinks();
            } catch (error) {
                const statusElement = document.querySelector(SELECTORS.STATUS);
                statusElement.textContent = 'Error loading links';
                statusElement.className = CSS_CLASSES.ERROR;
            }
        }

        /**
         * Saves the current links array to the server
         * @async
         */
        async function saveLinks() {
            try {
                const linksToSave = links.map(({ name, url, category }) => ({ name, url, category }));
                
                const response = await fetch('/api/links', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(linksToSave)
                });
                
                
                if (response.ok) {
                    const statusElement = document.querySelector(SELECTORS.STATUS);
                    statusElement.textContent = 'Links saved successfully';
                    statusElement.className = '';
                    setTimeout(() => {
                        statusElement.textContent = '';
                    }, STATUS_TIMEOUT);
                } else {
                    const errorText = await response.text();
                    throw new Error('Failed to save: ' + response.status);
                }
            } catch (error) {
                const statusElement = document.querySelector(SELECTORS.STATUS);
                statusElement.textContent = 'Error saving links: ' + error.message;
                statusElement.className = CSS_CLASSES.ERROR;
            }
        }

        document.querySelector(SELECTORS.ADD_SERVERS).onclick = () => {
            if (hasLinkInEditMode()) {
                showStatusMessage('Please finish editing the current link before adding a new one', true);
                return;
            }
            const newLink = { name: '', url: '', category: CATEGORIES.SERVERS, editing: true };
            links.push(newLink);
            renderLinks();
        };

        document.querySelector(SELECTORS.ADD_INFRASTRUCTURE).onclick = () => {
            if (hasLinkInEditMode()) {
                showStatusMessage('Please finish editing the current link before adding a new one', true);
                return;
            }
            const newLink = { name: '', url: '', category: CATEGORIES.INFRASTRUCTURE, editing: true };
            links.push(newLink);
            renderLinks();
        };

        document.querySelector(SELECTORS.ADD_MEDIA).onclick = () => {
            if (hasLinkInEditMode()) {
                showStatusMessage('Please finish editing the current link before adding a new one', true);
                return;
            }
            const newLink = { name: '', url: '', category: CATEGORIES.MEDIA, editing: true };
            links.push(newLink);
            renderLinks();
        };

        document.querySelector(SELECTORS.ADD_WEBSITES).onclick = () => {
            if (hasLinkInEditMode()) {
                showStatusMessage('Please finish editing the current link before adding a new one', true);
                return;
            }
            const newLink = { name: '', url: '', category: CATEGORIES.WEBSITES, editing: true };
            links.push(newLink);
            renderLinks();
        };

        // Load links when page loads
        loadLinks();

        // Initialize search functionality
        initializeSearch();
    </script>
</body>
</html>
